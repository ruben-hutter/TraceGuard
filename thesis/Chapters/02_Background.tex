% !TEX root = ../Thesis.tex
\chapter{Background}

This chapter establishes the theoretical foundations necessary for understanding the taint-guided symbolic execution optimization presented in this thesis. We examine symbolic execution, taint analysis, control flow analysis, and the Angr framework.

\section{Symbolic Execution}

Symbolic execution is a program analysis technique that explores execution paths by using symbolic variables instead of concrete inputs. The program state consists of symbolic variables, path constraints, and a program counter. When execution encounters a conditional branch, the engine explores both branches by adding appropriate constraints to the path condition.

A fundamental challenge in symbolic execution is the path explosion problem. As program complexity increases, the number of possible execution paths grows exponentially, making exhaustive exploration computationally intractable. This scalability issue particularly affects real-world applications with complex control flow structures and deep function call hierarchies. Research has shown that symbolic execution tools designed to optimize statement coverage often fail to cover potentially vulnerable code due to complex system interactions and scalability issues of constraint solvers \cite{schwartz_all_2010}.

Traditional symbolic execution typically employs a forward approach, starting from the program's entry point and exploring paths toward potential targets. However, this method may struggle to reach deeply nested functions or specific program locations of interest. Backward symbolic execution, conversely, begins from target locations and works backwards to identify input conditions that can reach those targets. Compositional approaches combine both techniques by analyzing individual functions in isolation and then reasoning about their interactions.

The scalability challenges of symbolic execution have motivated numerous optimization approaches, including state merging, constraint optimization, and path prioritization strategies. These optimization techniques form the foundation for more targeted analysis approaches that focus computational resources on security-relevant program behaviors.

\section{Taint Analysis}

Taint analysis tracks the propagation of data derived from untrusted sources throughout program execution. Data originating from designated sources (such as user input functions like \texttt{fgets}, \texttt{gets}, \texttt{read}, or \texttt{scanf}) is marked as ``tainted.'' The analysis tracks how this tainted data flows through assignments, function calls, and other operations. When tainted data reaches a security-sensitive sink (such as buffer operations or system calls), the analysis flags a potential vulnerability.

The propagation rules define how taint spreads through different operations: assignments involving tainted values result in tainted variables, arithmetic operations with tainted operands typically produce tainted results, and function calls with tainted arguments may result in tainted return values depending on the function's semantics. Dynamic taint analysis performs tracking during program execution, providing precise information about actual data flows while considering specific calling contexts and program states, resulting in reduced false positives compared to static analysis approaches.

The combination of taint analysis and symbolic execution creates a powerful analysis framework. Symbolic execution can explore multiple program paths while taint analysis identifies which paths involve security-relevant data flows. Research has demonstrated effective integration through pipelined approaches that achieve significant performance improvements while maintaining precision \cite{ming_taintpipe_2015}. This integration enables targeted exploration of paths that process untrusted input, significantly improving the efficiency of vulnerability discovery \cite{newsome_dynamic_2005}.

\section{Control Flow Analysis}

Control flow analysis examines the possible execution paths through a program by constructing and analyzing control flow graphs (CFGs). A CFG represents program structure where nodes correspond to basic blocks of sequential instructions and edges represent possible control transfers between blocks. This representation enables systematic analysis of program behavior and reachability properties.

Static analysis constructs CFGs by examining program code without executing it, analyzing structure and control flow based solely on the source code or binary representation. This approach offers comprehensive coverage and efficiency, enabling examination of all statically determinable program paths without requiring specific input values. However, static analysis faces limitations including difficulty with indirect call resolution and potential false positives due to conservative approximations required for soundness.

Dynamic analysis executes the program and collects runtime information, providing precise information about actual program behavior and complete execution context. This approach eliminates many false positives inherent in static analysis and validates that control flow relationships are actually exercised under realistic conditions. However, dynamic analysis results depend heavily on input quality and coverage.

A Call Graph represents function call relationships within a program, where each node corresponds to a function and each directed edge represents a call relationship. Call graphs serve important purposes including program understanding, entry point identification, reachability analysis, and complexity assessment. Call graphs prove valuable for path prioritization strategies, enabling identification of functions reachable from tainted input sources and assessment of their relative importance in program execution flow.

Modern analysis tools often combine both static and dynamic approaches. Hybrid techniques leverage the efficiency of static analysis for initial program understanding while using dynamic analysis to resolve ambiguities and validate findings under realistic execution conditions.

\section{Angr Framework}

Angr is an open-source binary analysis platform providing comprehensive capabilities for static and dynamic program analysis \cite{shoshitaishvili_sok_2016}. The platform supports multiple architectures and provides a Python-based interface for research and education \cite{springer_teaching_2018}. Key components include the Project object representing the binary under analysis with access to contents, symbols, and analysis capabilities; the Knowledge Base storing information gathered during analysis including function definitions and control flow graphs; the Simulation Manager handling multiple program states during symbolic execution and managing state transitions; and the Solver Engine interfacing with constraint solvers to determine path feasibility and solve for concrete input values.

Angr supports both static (\texttt{CFGFast}) and dynamic (\texttt{CFGEmulated}) CFG construction. Static analysis provides efficiency but may miss indirect calls, while dynamic analysis offers completeness at higher computational cost \cite{angr_documentation}. The static approach analyzes the binary without execution, making it efficient for initial program understanding, while dynamic analysis executes the program with sample inputs to discover reachable code, providing more complete coverage of actual execution paths and better handling of indirect calls.

Angr represents program states with register values, memory contents, path constraints, and execution history. The framework provides APIs for state inspection and manipulation, along with fine-grained execution control through step functions and exploration techniques. The step function advances execution by single instructions, enabling precise control over exploration processes, while various exploration strategies guide path selection including depth-first search, breadth-first search, and custom heuristics. Configuration options control execution behavior, such as handling of unconstrained memory and registers, allowing researchers to customize analysis behavior for specific research requirements.

The framework's extensible architecture enables integration of custom analysis techniques, making it particularly suitable for implementing novel symbolic execution optimizations. Angr's support for both static and dynamic analysis capabilities provides the foundation necessary for implementing taint-guided exploration strategies that combine control flow analysis with symbolic execution.

Multiple symbolic execution frameworks have been developed to address the scalability challenges discussed earlier \cite{baldoni_survey_2018}. While angr focuses on binary analysis and provides a comprehensive platform for security research, other frameworks target different domains and approaches. KLEE \cite{cadar_klee_2008} remains one of the most prominent tools for C programs, focusing on automatic test generation and providing extensive coverage analysis capabilities. SAGE \cite{godefroid_automated_2008} extends symbolic execution to binary code analysis through whitebox fuzzing, particularly effective for vulnerability discovery in Windows applications. CBMC \cite{clarke_behavioral_2003} offers bounded model checking for C/C++ programs with formal verification capabilities. Java PathFinder \cite{visser_model_2003} provides symbolic execution for Java bytecode with emphasis on model checking applications. Each framework offers distinct advantages: KLEE excels in systematic path exploration for source code, SAGE in practical vulnerability discovery for binaries, CBMC in formal verification, and Java PathFinder in model checking for Java applications.
